package antihog

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"net/http"
	"net/netip"
	"regexp"
	"strings"
	"time"

	"github.com/rs/zerolog/log"

	"github.com/gravitational/prehog/lib/posthog"
)

type jsonObject = map[string]any

func NewHandler(posthogClient *posthog.Client, autocapture bool) *Handler {
	var decide []byte
	// fetched by posthog-js at init time, to decide if it should enable
	// autocapture or not, and if it should use compression (we disable
	// compression for now)
	if autocapture {
		decide = []byte(`{"config":{"enable_collect_everything":true}}`)
	} else {
		decide = []byte(`{}`)
	}
	return &Handler{
		client: posthogClient,
		decide: decide,
	}
}

type Handler struct {
	client *posthog.Client
	decide []byte
}

func (h *Handler) Install(handleFunc func(string, func(http.ResponseWriter, *http.Request))) {
	handleFunc("/decide", h.ServeDecide)
	handleFunc("/decide/", h.ServeDecide)
	handleFunc("/e", h.ServeCapture)
	handleFunc("/e/", h.ServeCapture)
}

func (h *Handler) ServeDecide(w http.ResponseWriter, r *http.Request) {
	posthogCors(w, r)

	if r.Method != http.MethodGet && r.Method != http.MethodPost {
		return
	}

	w.Header().Set("content-type", "application/json")
	_, _ = w.Write(h.decide)
}

func (h *Handler) ServeCapture(w http.ResponseWriter, r *http.Request) {
	posthogCors(w, r)

	if r.Method != http.MethodGet && r.Method != http.MethodPost {
		return
	}

	// this will error out if the request body is bigger than some sane default (10MB)
	if err := r.ParseForm(); err != nil {
		http.Error(w, "invalid form", http.StatusBadRequest)
		return
	}

	base64Data := r.Form.Get("data")
	if base64Data == "" {
		http.Error(w, "missing data", http.StatusBadRequest)
		return
	}

	var remoteIP string
	if addrPort, err := netip.ParseAddrPort(r.RemoteAddr); err == nil {
		a := addrPort.Addr().Unmap()
		if a.IsGlobalUnicast() && !a.IsPrivate() {
			remoteIP = a.WithZone("").String()
		}
	}

	data, err := base64.StdEncoding.DecodeString(base64Data)
	if err != nil {
		return
	}

	var events []jsonObject
	if err := json.Unmarshal(data, &events); err != nil {
		var event jsonObject
		if err := json.Unmarshal(data, &event); err != nil {
			return
		}
		events = []jsonObject{event}
	}

	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()

	now := time.Now().UTC()

	for _, event := range events {
		h.submitEvent(ctx, now, remoteIP, event)
	}
}

// posthogUUID is a regular expression that matches the "uuid" generated by
// posthog-js (see _UUID in src/utils.ts). Crucially, this will disallow
// distinct_ids that match our distinct_id prefixes.
var posthogUUID = regexp.MustCompile("^[[:xdigit:]]+-[[:xdigit:]]+-[[:xdigit:]]{8}-[[:xdigit:]]+-[[:xdigit:]]+$")

func (h *Handler) submitEvent(ctx context.Context, now time.Time, remoteIP string, e jsonObject) {
	event, _ := e["event"].(string)
	switch event {
	// innocuous posthog-js events, as reported by a PostHog SWE on their
	// community slack
	case "$pageview", "$pageleave", "$autocapture", "$rageclick":
	default:
		log.Warn().Str("event", event).Msg("Skipping posthog-js event")
		return
	}

	properties, _ := e["properties"].(jsonObject)

	distinctID, _ := properties["distinct_id"].(string)
	delete(properties, "distinct_id")
	if !posthogUUID.MatchString(distinctID) {
		log.Warn().Str("distinct_id", distinctID).Msg("Skipping posthog-js event")
		return
	}

	delete(properties, "api_key")
	delete(properties, "token")

	offsetF, _ := e["offset"].(float64)
	offset := time.Duration(offsetF * float64(time.Millisecond))
	if offset < 0 || offset > 10*time.Second {
		offset = 0
	}

	if remoteIP != "" {
		properties["$ip"] = remoteIP
		delete(properties, "$geoip_disable")
	} else {
		delete(properties, "$ip")
		properties["$geoip_disable"] = true
	}

	properties["$lib"] = "antihog"

	set, _ := properties["$set"].(jsonObject)
	delete(properties, "$set")
	setOnce, _ := properties["$set_once"].(jsonObject)
	delete(properties, "$set_once")

	p := &posthog.Event{
		DistinctID: distinctID,
		Event:      posthog.EventName(event),
		Timestamp:  now.Add(-offset),
		Properties: make(map[posthog.EventProperty]any, len(properties)),
		Set:        make(map[posthog.PersonProperty]any, len(set)),
		SetOnce:    make(map[posthog.PersonProperty]any, len(setOnce)),
	}

	// TODO(espadolini): use an allowlist instead
	for k, v := range properties {
		if strings.HasPrefix(k, "tp.") {
			log.Warn().Str("properties", k).Msg("Skipping posthog-js event")
			return
		}
		p.Properties[posthog.EventProperty(k)] = v
	}

	for k, v := range set {
		if strings.HasPrefix(k, "tp.") {
			log.Warn().Str("$set", k).Msg("Skipping posthog-js event")
			return
		}
		p.Set[posthog.PersonProperty(k)] = v
	}

	for k, v := range setOnce {
		if strings.HasPrefix(k, "tp.") {
			log.Warn().Str("$set_once", k).Msg("Skipping posthog-js event")
			return
		}
		p.SetOnce[posthog.PersonProperty(k)] = v
	}

	dur, err := h.client.Emit(ctx, p)
	log.Err(err).Str("event", event).Dur("elapsed", dur).Msg("AntiHog Emit")
}

// posthogCors adds CORS headers to the response to a HTTP request, matching
// what posthog does (see cors_response in utils.py).
func posthogCors(w http.ResponseWriter, r *http.Request) {
	h := w.Header()
	origin := r.Header.Get("origin")
	if origin == "" {
		return
	}
	h.Set("access-control-allow-origin", origin)
	h.Set("access-control-allow-credentials", "true")
	h.Set("access-control-allow-methods", "GET, POST, OPTIONS")
}
