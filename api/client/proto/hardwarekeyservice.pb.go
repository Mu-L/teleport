// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: hardwarekeyservice.proto

package proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AttestHardwarePrivateKeyRequest is a request to AttestHardwarePrivateKey.
type AttestHardwarePrivateKeyRequest struct {
	// attestation_request is an attestation request for a hardware private key. The data
	// necessary for the request is dependent on the hardware key in question.
	//
	// Types that are valid to be assigned to AttestationRequest:
	//	*AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest
	AttestationRequest   isAttestHardwarePrivateKeyRequest_AttestationRequest `protobuf_oneof:"attestation_request"`
	XXX_NoUnkeyedLiteral struct{}                                             `json:"-"`
	XXX_unrecognized     []byte                                               `json:"-"`
	XXX_sizecache        int32                                                `json:"-"`
}

func (m *AttestHardwarePrivateKeyRequest) Reset()         { *m = AttestHardwarePrivateKeyRequest{} }
func (m *AttestHardwarePrivateKeyRequest) String() string { return proto.CompactTextString(m) }
func (*AttestHardwarePrivateKeyRequest) ProtoMessage()    {}
func (*AttestHardwarePrivateKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d07261bf1b876cc5, []int{0}
}
func (m *AttestHardwarePrivateKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestHardwarePrivateKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestHardwarePrivateKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestHardwarePrivateKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestHardwarePrivateKeyRequest.Merge(m, src)
}
func (m *AttestHardwarePrivateKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *AttestHardwarePrivateKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestHardwarePrivateKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttestHardwarePrivateKeyRequest proto.InternalMessageInfo

type isAttestHardwarePrivateKeyRequest_AttestationRequest interface {
	isAttestHardwarePrivateKeyRequest_AttestationRequest()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest struct {
	YubikeyAttestationRequest *YubikeyAttestationRequest `protobuf:"bytes,1,opt,name=yubikey_attestation_request,json=yubikeyAttestationRequest,proto3,oneof" json:"yubikey_attestation_request,omitempty"`
}

func (*AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest) isAttestHardwarePrivateKeyRequest_AttestationRequest() {
}

func (m *AttestHardwarePrivateKeyRequest) GetAttestationRequest() isAttestHardwarePrivateKeyRequest_AttestationRequest {
	if m != nil {
		return m.AttestationRequest
	}
	return nil
}

func (m *AttestHardwarePrivateKeyRequest) GetYubikeyAttestationRequest() *YubikeyAttestationRequest {
	if x, ok := m.GetAttestationRequest().(*AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest); ok {
		return x.YubikeyAttestationRequest
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AttestHardwarePrivateKeyRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest)(nil),
	}
}

// YubikeyAttestationRequest is data used to attest a specific Yubikey PIV slot.
type YubikeyAttestationRequest struct {
	// slot_cert is a certificate signed by the yubikey's attestation certificate using the slot's
	// public key.
	SlotCert []byte `protobuf:"bytes,1,opt,name=slot_cert,json=slotCert,proto3" json:"slot_cert,omitempty"`
	// attestation_cert is the attestation certificate signed by a Yubikey CA for the yubikey in
	// question.
	AttestationCert      []byte   `protobuf:"bytes,2,opt,name=attestation_cert,json=attestationCert,proto3" json:"attestation_cert,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *YubikeyAttestationRequest) Reset()         { *m = YubikeyAttestationRequest{} }
func (m *YubikeyAttestationRequest) String() string { return proto.CompactTextString(m) }
func (*YubikeyAttestationRequest) ProtoMessage()    {}
func (*YubikeyAttestationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d07261bf1b876cc5, []int{1}
}
func (m *YubikeyAttestationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *YubikeyAttestationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_YubikeyAttestationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *YubikeyAttestationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_YubikeyAttestationRequest.Merge(m, src)
}
func (m *YubikeyAttestationRequest) XXX_Size() int {
	return m.Size()
}
func (m *YubikeyAttestationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_YubikeyAttestationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_YubikeyAttestationRequest proto.InternalMessageInfo

func (m *YubikeyAttestationRequest) GetSlotCert() []byte {
	if m != nil {
		return m.SlotCert
	}
	return nil
}

func (m *YubikeyAttestationRequest) GetAttestationCert() []byte {
	if m != nil {
		return m.AttestationCert
	}
	return nil
}

// AttestHardwarePrivateKeyResponse is a response to AttestHardwarePrivateKey.
type AttestHardwarePrivateKeyResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttestHardwarePrivateKeyResponse) Reset()         { *m = AttestHardwarePrivateKeyResponse{} }
func (m *AttestHardwarePrivateKeyResponse) String() string { return proto.CompactTextString(m) }
func (*AttestHardwarePrivateKeyResponse) ProtoMessage()    {}
func (*AttestHardwarePrivateKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d07261bf1b876cc5, []int{2}
}
func (m *AttestHardwarePrivateKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestHardwarePrivateKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestHardwarePrivateKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestHardwarePrivateKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestHardwarePrivateKeyResponse.Merge(m, src)
}
func (m *AttestHardwarePrivateKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *AttestHardwarePrivateKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestHardwarePrivateKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AttestHardwarePrivateKeyResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*AttestHardwarePrivateKeyRequest)(nil), "proto.AttestHardwarePrivateKeyRequest")
	proto.RegisterType((*YubikeyAttestationRequest)(nil), "proto.YubikeyAttestationRequest")
	proto.RegisterType((*AttestHardwarePrivateKeyResponse)(nil), "proto.AttestHardwarePrivateKeyResponse")
}

func init() { proto.RegisterFile("hardwarekeyservice.proto", fileDescriptor_d07261bf1b876cc5) }

var fileDescriptor_d07261bf1b876cc5 = []byte{
	// 253 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0xc8, 0x48, 0x2c, 0x4a,
	0x29, 0x4f, 0x2c, 0x4a, 0xcd, 0x4e, 0xad, 0x2c, 0x4e, 0x2d, 0x2a, 0xcb, 0x4c, 0x4e, 0xd5, 0x2b,
	0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x05, 0x53, 0x4a, 0x73, 0x18, 0xb9, 0xe4, 0x1d, 0x4b, 0x4a,
	0x52, 0x8b, 0x4b, 0x3c, 0xa0, 0x2a, 0x03, 0x8a, 0x32, 0xcb, 0x12, 0x4b, 0x52, 0xbd, 0x53, 0x2b,
	0x83, 0x52, 0x0b, 0x4b, 0x53, 0x8b, 0x4b, 0x84, 0x92, 0xb8, 0xa4, 0x2b, 0x4b, 0x93, 0x32, 0xb3,
	0x53, 0x2b, 0xe3, 0x13, 0xc1, 0x4a, 0x13, 0x4b, 0x32, 0xf3, 0xf3, 0xe2, 0x8b, 0x20, 0xd2, 0x12,
	0x8c, 0x0a, 0x8c, 0x1a, 0xdc, 0x46, 0x0a, 0x10, 0x73, 0xf5, 0x22, 0x21, 0x2a, 0x1d, 0x11, 0x0a,
	0xa1, 0xc6, 0x78, 0x30, 0x04, 0x49, 0x56, 0xe2, 0x92, 0x74, 0x12, 0xe5, 0x12, 0xc6, 0x62, 0xb6,
	0x52, 0x32, 0x97, 0x24, 0x4e, 0x03, 0x85, 0xa4, 0xb9, 0x38, 0x8b, 0x73, 0xf2, 0x4b, 0xe2, 0x93,
	0x53, 0x8b, 0x20, 0xae, 0xe0, 0x09, 0xe2, 0x00, 0x09, 0x38, 0xa7, 0x16, 0x95, 0x08, 0x69, 0x72,
	0x09, 0x20, 0x1b, 0x08, 0x56, 0xc3, 0x04, 0x56, 0xc3, 0x8f, 0x24, 0x0e, 0x52, 0xaa, 0xa4, 0xc4,
	0xa5, 0x80, 0x3b, 0x08, 0x8a, 0x0b, 0xf2, 0xf3, 0x8a, 0x53, 0x8d, 0x1a, 0x19, 0xb9, 0x84, 0x60,
	0xd2, 0xde, 0xa9, 0x95, 0xc1, 0x90, 0xb0, 0x14, 0xca, 0xe6, 0x92, 0xc0, 0xa5, 0x55, 0x48, 0x0d,
	0x1a, 0x22, 0x04, 0x82, 0x57, 0x4a, 0x9d, 0xa0, 0x3a, 0x88, 0x1b, 0x9c, 0x78, 0x4e, 0x3c, 0x92,
	0x63, 0xbc, 0xf0, 0x48, 0x8e, 0xf1, 0xc1, 0x23, 0x39, 0xc6, 0x24, 0x36, 0xb0, 0x2e, 0x63, 0x40,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x39, 0xda, 0x58, 0xc6, 0xe3, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// HardwareKeyServiceClient is the client API for HardwareKeyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type HardwareKeyServiceClient interface {
	// AttestHardwarePrivateKey is used to perform a server-side attestation check for a
	// hardware-backed private key.
	AttestHardwarePrivateKey(ctx context.Context, in *AttestHardwarePrivateKeyRequest, opts ...grpc.CallOption) (*AttestHardwarePrivateKeyResponse, error)
}

type hardwareKeyServiceClient struct {
	cc *grpc.ClientConn
}

func NewHardwareKeyServiceClient(cc *grpc.ClientConn) HardwareKeyServiceClient {
	return &hardwareKeyServiceClient{cc}
}

func (c *hardwareKeyServiceClient) AttestHardwarePrivateKey(ctx context.Context, in *AttestHardwarePrivateKeyRequest, opts ...grpc.CallOption) (*AttestHardwarePrivateKeyResponse, error) {
	out := new(AttestHardwarePrivateKeyResponse)
	err := c.cc.Invoke(ctx, "/proto.HardwareKeyService/AttestHardwarePrivateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HardwareKeyServiceServer is the server API for HardwareKeyService service.
type HardwareKeyServiceServer interface {
	// AttestHardwarePrivateKey is used to perform a server-side attestation check for a
	// hardware-backed private key.
	AttestHardwarePrivateKey(context.Context, *AttestHardwarePrivateKeyRequest) (*AttestHardwarePrivateKeyResponse, error)
}

// UnimplementedHardwareKeyServiceServer can be embedded to have forward compatible implementations.
type UnimplementedHardwareKeyServiceServer struct {
}

func (*UnimplementedHardwareKeyServiceServer) AttestHardwarePrivateKey(ctx context.Context, req *AttestHardwarePrivateKeyRequest) (*AttestHardwarePrivateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttestHardwarePrivateKey not implemented")
}

func RegisterHardwareKeyServiceServer(s *grpc.Server, srv HardwareKeyServiceServer) {
	s.RegisterService(&_HardwareKeyService_serviceDesc, srv)
}

func _HardwareKeyService_AttestHardwarePrivateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttestHardwarePrivateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HardwareKeyServiceServer).AttestHardwarePrivateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.HardwareKeyService/AttestHardwarePrivateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HardwareKeyServiceServer).AttestHardwarePrivateKey(ctx, req.(*AttestHardwarePrivateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _HardwareKeyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.HardwareKeyService",
	HandlerType: (*HardwareKeyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AttestHardwarePrivateKey",
			Handler:    _HardwareKeyService_AttestHardwarePrivateKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hardwarekeyservice.proto",
}

func (m *AttestHardwarePrivateKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestHardwarePrivateKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttestHardwarePrivateKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AttestationRequest != nil {
		{
			size := m.AttestationRequest.Size()
			i -= size
			if _, err := m.AttestationRequest.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.YubikeyAttestationRequest != nil {
		{
			size, err := m.YubikeyAttestationRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHardwarekeyservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *YubikeyAttestationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *YubikeyAttestationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *YubikeyAttestationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AttestationCert) > 0 {
		i -= len(m.AttestationCert)
		copy(dAtA[i:], m.AttestationCert)
		i = encodeVarintHardwarekeyservice(dAtA, i, uint64(len(m.AttestationCert)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SlotCert) > 0 {
		i -= len(m.SlotCert)
		copy(dAtA[i:], m.SlotCert)
		i = encodeVarintHardwarekeyservice(dAtA, i, uint64(len(m.SlotCert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttestHardwarePrivateKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestHardwarePrivateKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttestHardwarePrivateKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintHardwarekeyservice(dAtA []byte, offset int, v uint64) int {
	offset -= sovHardwarekeyservice(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AttestHardwarePrivateKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttestationRequest != nil {
		n += m.AttestationRequest.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.YubikeyAttestationRequest != nil {
		l = m.YubikeyAttestationRequest.Size()
		n += 1 + l + sovHardwarekeyservice(uint64(l))
	}
	return n
}
func (m *YubikeyAttestationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SlotCert)
	if l > 0 {
		n += 1 + l + sovHardwarekeyservice(uint64(l))
	}
	l = len(m.AttestationCert)
	if l > 0 {
		n += 1 + l + sovHardwarekeyservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttestHardwarePrivateKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovHardwarekeyservice(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozHardwarekeyservice(x uint64) (n int) {
	return sovHardwarekeyservice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AttestHardwarePrivateKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHardwarekeyservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestHardwarePrivateKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestHardwarePrivateKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YubikeyAttestationRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHardwarekeyservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &YubikeyAttestationRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AttestationRequest = &AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHardwarekeyservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *YubikeyAttestationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHardwarekeyservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: YubikeyAttestationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: YubikeyAttestationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotCert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHardwarekeyservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlotCert = append(m.SlotCert[:0], dAtA[iNdEx:postIndex]...)
			if m.SlotCert == nil {
				m.SlotCert = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationCert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHardwarekeyservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationCert = append(m.AttestationCert[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationCert == nil {
				m.AttestationCert = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHardwarekeyservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestHardwarePrivateKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHardwarekeyservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestHardwarePrivateKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestHardwarePrivateKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipHardwarekeyservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHardwarekeyservice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHardwarekeyservice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHardwarekeyservice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHardwarekeyservice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthHardwarekeyservice
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupHardwarekeyservice
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthHardwarekeyservice
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthHardwarekeyservice        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHardwarekeyservice          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupHardwarekeyservice = fmt.Errorf("proto: unexpected end of group")
)
