/*
Copyright 2022 Gravitational, Inc.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package keys

import (
	"crypto"
	"crypto/rand"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"io"
	"math/big"
	"strconv"
	"strings"
	"time"

	"github.com/go-piv/piv-go/piv"
	"github.com/gravitational/teleport/api"
	"github.com/gravitational/trace"
	"golang.org/x/crypto/ssh"
	"golang.org/x/crypto/ssh/agent"
	"gopkg.in/yaml.v2"
)

const (
	// PIVCardTypeYubikey is the PIV card type assigned to yubikeys.
	PIVCardTypeYubikey = "yubikey"
)

var (
	// We use slot 9a for Teleport Clients which require `private_key_policy: hardware_key`.
	pivSlotNoTouch = piv.SlotAuthentication
	// We use slot 9c for Teleport Clients which require `private_key_policy: hardware_key_touch`.
	pivSlotWithTouch = piv.SlotSignature
)

// GetOrGenerateYubikeyPrivateKey connects to the yubikey with the given serial number and gets a private key
// matching the given touch requirement. This private key will either be newly generated or previously
// generated by a Teleport client and reused.
func GetOrGenerateYubikeyPrivateKey(touchRequired bool) (*PrivateKey, error) {
	// Use the first yubikey we find.
	y, err := findYubikey("")
	if err != nil {
		return nil, trace.Wrap(err)
	}

	// Get the correct PIV slot and Touch policy for the given touch requirement:
	//  - No Touch = 9a + TouchPolicyNever
	//  - Touch    = 9c + TouchPolicyCached
	pivSlot := pivSlotNoTouch
	touchPolicy := piv.TouchPolicyNever
	if touchRequired {
		pivSlot = pivSlotWithTouch
		touchPolicy = piv.TouchPolicyCached
	}

	// First, check if there is already a private key set up by a Teleport Client.
	priv, err := y.getPrivateKey(pivSlot)
	if err != nil {
		// Generate a new private key on the PIV slot.
		if priv, err = y.generatePrivateKey(pivSlot, touchPolicy); err != nil {
			return nil, trace.Wrap(err)
		}
	}

	return NewPrivateKey(priv)
}

// YubikeyPrivateKey is a Yubikey PIV private key. Cryptographical operations open
// a new temporary connection to the PIV card to perform the operation.
type YubikeyPrivateKey struct {
	// yubikey is a specific yubikey PIV module.
	*yubikey
	pivSlot      piv.Slot
	keyDataBytes []byte
	pub          crypto.PublicKey
	sshPub       ssh.PublicKey
}

// yubikeyPrivateKeyData is marshalable data used to retrieve a specific yubikey PIV private key.
type yubikeyPrivateKeyData struct {
	SerialNumber string `yaml:"serial_number"`
	PIVSlot      string `yaml:"piv_slot"`
}

func newYubikeyPrivateKey(y *yubikey, slot piv.Slot, pub crypto.PublicKey) (*YubikeyPrivateKey, error) {
	sshPub, err := ssh.NewPublicKey(pub)
	if err != nil {
		return nil, trace.Wrap(err)
	}

	keyDataBytes, err := yaml.Marshal(yubikeyPrivateKeyData{
		SerialNumber: strconv.FormatUint(uint64(y.serialNumber), 10),
		PIVSlot:      slot.String(),
	})
	if err != nil {
		return nil, trace.Wrap(err)
	}

	return &YubikeyPrivateKey{
		yubikey:      y,
		pivSlot:      slot,
		pub:          pub,
		sshPub:       sshPub,
		keyDataBytes: keyDataBytes,
	}, nil
}

func parseYubikeyPrivateKeyData(keyDataBytes []byte) (*YubikeyPrivateKey, error) {
	var keyData yubikeyPrivateKeyData
	if err := yaml.Unmarshal(keyDataBytes, &keyData); err != nil {
		return nil, trace.Wrap(err)
	}

	y, err := findYubikey(keyData.SerialNumber)
	if err != nil {
		return nil, trace.Wrap(err)
	}

	pivSlot, err := parsePIVSlot(keyData.PIVSlot)
	if err != nil {
		return nil, trace.Wrap(err)
	}

	return y.getPrivateKey(pivSlot)
}

// Public returns the public key corresponding to this private key.
func (y *YubikeyPrivateKey) Public() crypto.PublicKey {
	return y.pub
}

// Sign implements crypto.Signer.
func (y *YubikeyPrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) (signature []byte, err error) {
	yk, err := y.open()
	if err != nil {
		return nil, trace.Wrap(err)
	}
	defer yk.Close()

	privateKey, err := yk.PrivateKey(pivSlotNoTouch, y.pub, piv.KeyAuth{})
	if err != nil {
		return nil, trace.Wrap(err)
	}

	return privateKey.(crypto.Signer).Sign(rand, digest, opts)
}

// PrivateKeyPEM returns PEM encoded data about this yubikey private key.
func (y *YubikeyPrivateKey) PrivateKeyPEM() []byte {
	return pem.EncodeToMemory(&pem.Block{
		Type:    pivYubikeyPrivateKeyType,
		Headers: nil,
		Bytes:   y.keyDataBytes,
	})
}

// SSHPublicKey returns the ssh.PublicKey representiation of the public key.
func (y *YubikeyPrivateKey) SSHPublicKey() ssh.PublicKey {
	return y.sshPub
}

// TLSCertificate parses the given TLS certificate paired with the private key
// to rerturn a tls.Certificate, ready to be used in a TLS handshake.
func (y *YubikeyPrivateKey) TLSCertificate(cert []byte) (tls.Certificate, error) {
	certPEMBlock, _ := pem.Decode(cert)
	return tls.Certificate{
		Certificate: [][]byte{certPEMBlock.Bytes},
		PrivateKey:  y,
	}, nil
}

// AsAgentKeys returns an empty list, because x/crypto/ssh/agent does not support
// adding token agent keys currently.
func (y *YubikeyPrivateKey) AsAgentKeys(cert *ssh.Certificate) []agent.AddedKey {
	return []agent.AddedKey{}
}

// yubikey is a specific yubikey PIV card.
type yubikey struct {
	// card is a reader name used to find and connect to this yubikey.
	// This value may change between OS's, or with other system changes.
	card string
	// serialNumber is the yubikey's 8 digit serial number.
	serialNumber uint32
}

func newYubikey(card string) (*yubikey, error) {
	y := &yubikey{card: card}

	yk, err := y.open()
	if err != nil {
		return nil, trace.Wrap(err)
	}
	defer yk.Close()

	y.serialNumber, err = yk.Serial()
	if err != nil {
		return nil, trace.Wrap(err)
	}

	return y, nil
}

// generatePrivateKey generates a new private key from the given PIV slot with the given PIV policies.
func (y *yubikey) generatePrivateKey(slot piv.Slot, touchPolicy piv.TouchPolicy) (*YubikeyPrivateKey, error) {
	yk, err := y.open()
	if err != nil {
		return nil, trace.Wrap(err)
	}
	defer yk.Close()

	opts := piv.Key{
		Algorithm:   piv.AlgorithmEC256,
		PINPolicy:   piv.PINPolicyNever,
		TouchPolicy: touchPolicy,
	}
	pub, err := yk.GenerateKey(piv.DefaultManagementKey, slot, opts)
	if err != nil {
		return nil, trace.Wrap(err)
	}

	// Create a self signed certificate and store it in the PIV slot so that other
	// Teleport Clients know to reuse the stored key instead of genearting a new one.
	priv, err := yk.PrivateKey(slot, pub, piv.KeyAuth{})
	if err != nil {
		return nil, trace.Wrap(err)
	}

	cert, err := selfSignedTeleportClientCertificate(priv, pub)
	if err != nil {
		return nil, trace.Wrap(err)
	}

	// Store an unsigned certificate to mark this slot as used by tsh.
	if err = yk.SetCertificate(piv.DefaultManagementKey, slot, cert); err != nil {
		return nil, trace.Wrap(err)
	}

	return newYubikeyPrivateKey(y, slot, pub)
}

// getPrivateKey gets an existing private key from the given PIV slot.
func (y *yubikey) getPrivateKey(slot piv.Slot) (*YubikeyPrivateKey, error) {
	yk, err := y.open()
	if err != nil {
		return nil, trace.Wrap(err)
	}
	defer yk.Close()

	// Check the slot's certificate to see if it contains a self signed Teleport Client cert.
	cert, err := yk.Certificate(slot)
	if err != nil || cert == nil {
		return nil, trace.NotFound("Yubikey certificate slot is empty, expected a Teleport Client cert")
	} else if len(cert.Subject.Organization) == 0 || cert.Subject.Organization[0] != certOrgName {
		return nil, trace.NotFound("Yubikey certificate slot contained unknown certificate:\n%+v", cert)
	}

	// Attest the key to make sure it hasn't been imported.
	slotCert, err := yk.Attest(slot)
	if err != nil {
		return nil, trace.Wrap(err)
	}
	attestationCert, err := yk.AttestationCertificate()
	if err != nil {
		return nil, trace.Wrap(err)
	}
	if _, err = piv.Verify(attestationCert, slotCert); err != nil {
		return nil, trace.Wrap(err)
	}

	// Verify that the slot's certs have the same public key, otherwise the key
	// may have been generated by a non-teleport client.
	if !cert.PublicKey.(interface{ Equal(x crypto.PublicKey) bool }).Equal(slotCert.PublicKey) {
		return nil, trace.NotFound("Yubikey slot contains mismatched certificates and must be regenerated")
	}

	return newYubikeyPrivateKey(y, slot, slotCert.PublicKey)
}

// open a connection to yubikey PIV module. The returned connection should be closed once
// it's been used. The yubikey PIV module itself takes some additional time to handle closed
// connections, so we use a retry loop to give the PIV module time to close prior connections.
func (y *yubikey) open() (yk *piv.YubiKey, err error) {
	isRetryError := func(err error) bool {
		retryError := "connecting to smart card: the smart card cannot be accessed because of other connections outstanding"
		return strings.Contains(err.Error(), retryError)
	}

	var maxRetries int = 100
	for i := 0; i < maxRetries; i++ {
		yk, err = piv.Open(y.card)
		if err == nil {
			return yk, nil
		}

		if !isRetryError(err) {
			return nil, trace.Wrap(err)
		}

		time.Sleep(time.Millisecond * 100)
	}

	return nil, trace.Wrap(err)
}

// findYubikey finds a yubikey PIV card by serial number. If no serial
// number is provided, the first yubikey found will be returned.
func findYubikey(serialNumber string) (*yubikey, error) {
	yubikeyCards, err := findYubikeyCards()
	if err != nil {
		return nil, trace.Wrap(err)
	}

	for _, card := range yubikeyCards {
		y, err := newYubikey(card)
		if err != nil {
			return nil, trace.Wrap(err)
		}

		if serialNumber == "" || strconv.FormatUint(uint64(y.serialNumber), 10) == serialNumber {
			return y, nil
		}
	}

	return nil, trace.NotFound("no yubikey device found with serial number %q", serialNumber)
}

// findYubikeyCards returns a list of connected yubikey PIV card names.
func findYubikeyCards() ([]string, error) {
	cards, err := piv.Cards()
	if err != nil {
		return nil, trace.Wrap(err)
	}

	var yubikeyCards []string
	for _, card := range cards {
		if strings.Contains(strings.ToLower(card), PIVCardTypeYubikey) {
			yubikeyCards = append(yubikeyCards, card)
		}
	}

	if len(yubikeyCards) == 0 {
		return nil, trace.NotFound("no yubikey devices found")
	}

	return yubikeyCards, nil
}

func parsePIVSlot(slotName string) (piv.Slot, error) {
	key, err := strconv.ParseUint(slotName, 16, 32)
	if err != nil {
		return piv.Slot{}, trace.Wrap(err)
	}

	switch uint32(key) {
	case piv.SlotAuthentication.Key:
		return piv.SlotAuthentication, nil
	case piv.SlotSignature.Key:
		return piv.SlotSignature, nil
	case piv.SlotCardAuthentication.Key:
		return piv.SlotCardAuthentication, nil
	case piv.SlotKeyManagement.Key:
		return piv.SlotKeyManagement, nil
	}

	retiredSlot, ok := piv.RetiredKeyManagementSlot(uint32(key))
	if !ok {
		return piv.Slot{}, trace.BadParameter("slot %q does not exist", slotName)
	}
	return retiredSlot, nil
}

// certOrgName is used to identify Teleport Client self-signed certificates stored in yubikey PIV slots.
const certOrgName = "teleport"

func selfSignedTeleportClientCertificate(priv crypto.PrivateKey, pub crypto.PublicKey) (*x509.Certificate, error) {
	serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
	serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
	if err != nil {
		return nil, trace.Wrap(err)
	}
	cert := &x509.Certificate{
		SerialNumber: serialNumber,
		PublicKey:    pub,
		Subject: pkix.Name{
			Organization:       []string{certOrgName},
			OrganizationalUnit: []string{api.Version},
		},
	}
	if cert.Raw, err = x509.CreateCertificate(rand.Reader, cert, cert, pub, priv); err != nil {
		return nil, trace.Wrap(err)
	}
	return cert, nil
}
